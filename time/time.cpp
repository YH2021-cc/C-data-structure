//时间复杂度:衡量一个算法的运行快慢
//计算:就是计算算法基本操作的执行次数,通过它来确定算法的时间复杂度
#include<stdio.h>

//嵌套循环复杂度的计算
//计算fun1中++count共执行了多少次
void Fun1(int N)
{
	int count = 0;
	for (int i = 0; i < N; i++)			//这里执行了n*n次
	{
		for (int j = 0; j < N; j++) {
			++count;
		}
	}
	for (int k = 0; k < 2 * N; k++)		//这里执行了2*n次
	{
		++count;
	}
	int M = 10;
	while (M--)							//这里执行了10次
	{
		++count;
	}printf("%d", count);
}
//计算:将每个for循环里count执行的次数相加即为总复杂度
//fun函数的时间复杂度和未知数n有关,计算:F(N)=n*n+2*n+10,
/*
	n=10	执行次数 130
	n=100	执行次数 10210
	n=1000	执行次数 1002010

	可以看到n越大后两项对结果影响越小,可以省略后两项

	实际计算不需要计算精确的执行次数,只需要大概执行次数,因此可以省略对结果影响小的项
	因此用大O表示法就是O(N^2)

	所以当我们计算时间复杂度时先计算精确的,再省略对结果影响小的项
*/
/*
	大O表示法规则
		1.用1取代运行中的所有加法常数
		2.只保留最高阶项
		3.如果最高阶项存在且不是1,剔除与该项相乘的常数

	F(N)=n*n+2*n+10用大O表述-->F(N)=n*n+2*n+1-->F(N)=n^2-->O(N^2)
*/
//练习
//计算fun2的时间复杂度
void Fun2(int N, int M)
{
	int count = 0;
	for (int i = 0; i < M; i++)		//这里执行了M次
	{
		++count;
	}
	for (int k = 0; k < N; k++)		//这里执行了N次
	{
		++count;
	}
	//O(M+N)-->要是加上M远大于N条件就是O(M)反之同理,若M和N差不多大可为O(M)/O(N)
	//一般情况下未知数用N表示也可以用其他的如K,M表示
	//若是执行次数只有常数则为O(1)--所以常数循环都为O(1)
	//O(1)不是代表算法运行一次,是常数次
}
int main()
{
	return 0;
}